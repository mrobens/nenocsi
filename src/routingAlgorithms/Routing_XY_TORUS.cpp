/*
 * Noxim - the NoC Simulator
 *
 * (C) 2005-2018 by the University of Catania
 * For the complete list of authors refer to file ../../doc/AUTHORS.txt
 * For the license applied to these sources refer to file ../../doc/LICENSE.txt
 */
/*\\\********************************************************************************
 * Downloaded March 23, 2022 from
 * https://github.com/davidepatti/noxim/tree/c52ebce2217e57bcd4ff11a97b400323bd00acd5
 ************************************************************************************
 *
 * NENoCSi: Patched version of Noxim to process traffic generated by NEST
 * Modifications Copyright (C) 2022-2023 Forschungszentrum Juelich GmbH, ZEA-2
 * Author: Markus Robens <https://www.fz-juelich.de/profile/robens_m>
 * For the license applied to these modifications and NENoCSi as a whole
 * refer to file ../../doc/LICENSE_NENOCSI.txt
 * 
 * This file was modified on April 20, 2022 to enable XY routing in torus
 * shaped networks.
 *
 *///******************************************************************************** 
#include "Routing_XY_TORUS.h"

RoutingAlgorithmsRegister Routing_XY_TORUS::routingAlgorithmsRegister("XY_TORUS", getInstance());

Routing_XY_TORUS * Routing_XY_TORUS::routing_XY_TORUS = 0;

Routing_XY_TORUS * Routing_XY_TORUS::getInstance() {
	if ( routing_XY_TORUS == 0 )
		routing_XY_TORUS = new Routing_XY_TORUS();
    
	return routing_XY_TORUS;
}

vector<int> Routing_XY_TORUS::route(Router * router, const RouteData & routeData)
{
    Coord current = id2Coord(routeData.current_id);
    Coord destination = id2Coord(routeData.dst_id);
    vector <int> directions;
    int x_th = GlobalParams::mesh_dim_x / 2;
    int y_th = GlobalParams::mesh_dim_y / 2;
    bool rev_x = (abs(destination.x - current.x) > x_th) ? true : false;
    bool rev_y = (abs(destination.y - current.y) > y_th) ? true : false;

    if (((!rev_x) && (destination.x > current.x)) || (rev_x && (destination.x < current.x)))
        directions.push_back(DIRECTION_EAST);
    else if (((!rev_x) && (destination.x < current.x)) || (rev_x && (destination.x > current.x)))
        directions.push_back(DIRECTION_WEST);
    else if (((!rev_y) && (destination.y > current.y)) || (rev_y && (destination.y < current.y)))
        directions.push_back(DIRECTION_SOUTH);
    else
        directions.push_back(DIRECTION_NORTH);

    return directions;
   } 
