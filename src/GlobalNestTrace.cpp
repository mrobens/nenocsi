/*
 * Noxim - the NoC Simulator
 *
 * (C) 2005-2018 by the University of Catania
 * For the complete list of authors refer to file ../doc/AUTHORS.txt
 * For the license applied to these sources refer to file ../doc/LICENSE.txt
 *
 * This file contains the implementation of the global traffic table
 */
/*\\\********************************************************************************
 * Downloaded March 23, 2022 from
 * https://github.com/davidepatti/noxim/tree/c52ebce2217e57bcd4ff11a97b400323bd00acd5
 ************************************************************************************
 *
 * NENoCSi: Patched version of Noxim to process traffic generated by NEST
 * Modifications Copyright (C) 2022-2023 Forschungszentrum Juelich GmbH, ZEA-2
 * Author: Markus Robens <https://www.fz-juelich.de/profile/robens_m>
 * For the license applied to these modifications and NENoCSi as a whole
 * refer to file ../doc/LICENSE_NENOCSI.txt
 * 
 * GlobalNestTrace.cpp is loosely based on GlobalTrafficTable.cpp.
 * The file has been created on March 27, 2022 and was modified on April 29, 2022,
 * September 18, 2022, October 10, 2022, and October 17, 2022.
 * It has been largely revised in order to populate and query node specific queues 
 * for traffic caused by NEST. In addition, statistics on burst lengths are 
 * calculated. 
 * Some inspiration was taken from SpiNeMap as proposed in A. Balaji, F. Catthor, 
 * A. Das, Y. Wu, K. Huynh, F. G. Dell'Anna, G. Indiveri, J. L. Krichmar, N. D. Dutt, 
 * and S. Schaafsma, "Mapping Spiking Neural Networks to Neuromorphic Hardware," 
 * IEEE Transactions on Very Large Scale Integration (VLSI) Systems, Vol. 28, No. 1, 
 * January 2020, doi: 10.1109/TVLSI.2019.2951493.
 *
 *///*********************************************************************************

#include "yaml-cpp/yaml.h"
#include "GlobalNestTrace.h"
#include "GlobalParams.h"
#include <iostream>

GlobalNestTrace::GlobalNestTrace()
{
  valid = false;
}

bool GlobalNestTrace::load(const std::string &fname)
{
  // Load YAML document
  YAML::Node nestTraceDoc;
  try {
    nestTraceDoc = YAML::LoadFile( fname );
    std::cout << "Loaded NEST YAML input file " << fname << "." << std::endl;
  }
  catch (YAML::BadFile &e) {
    std::cout << "Failed loading NEST input." << std::endl;
    std::cerr << "The specified YAML file was not found!" << std::endl;
    return false;
  }
  catch (YAML::ParserException &pe) {
    std::cout << "Failed loading NEST input." << std::endl;
    std::cerr << "ERROR at line " << pe.mark.line + 1 << " column " << pe.mark.column + 1 << ": " << pe.msg << ". Please check indentation." << std::endl;
    return false;
  }
  NestTraffic.clear();
  NestBurstStats.clear();                                                                                                         // MR: Added 2022/04/29
  for (YAML::const_iterator itDoc = nestTraceDoc.begin(); itDoc != nestTraceDoc.end(); ++itDoc) {
    int total_bursts = 0;                                                                                                         // MR: Added 2022/04/29
    int max_nest_burst = 0;                                                                                                       // MR: Added 2022/04/29
    double avg_nest_burst = 0;                                                                                                    // MR: Added 2022/04/29
    for (YAML::const_iterator itLst = itDoc->second.begin(); itLst != itDoc->second.end(); ++itLst) {
      YAML::const_iterator itTime = (*itLst).begin();
      int burst_length = 0;                                                                                                       // MR: Added 2022/04/29
      for (YAML::const_iterator itTrgt = itTime->second.begin(); itTrgt != itTime->second.end(); ++itTrgt) {
	NestTraceComm ntc;
	ntc.time = GlobalParams::reset_time + GlobalParams::stats_warm_up_time + t_nest_to_cycle(itTime->first.as<double>());
	ntc.src_nd = itDoc->first.as<int>();
	ntc.dst_nd = itTrgt->first.as<int>();
	ntc.flt_tot = itTrgt->second.as<int>();
	ntc.flt_snt = 0;
	NestTraffic[ntc.src_nd].push(ntc);
	/* MR 29 Apr, 2022: Note
	 * Processing as shown above is possible, since events are sequentially ordered and the
	 * source IDs are filtered out from the destination lists before write-out from PyNEST
         */
	burst_length += itTrgt->second.as<int>();
      }
      // MR 29 Apr, 2022: Evaluation of burst statistics
      avg_nest_burst = burst_length / (double) (total_bursts + 1) +                                                               // MR: Added 2022/04/29
	avg_nest_burst * (double) total_bursts / (double) (total_bursts + 1);                                                     // MR: Added 2022/04/29 
      if (burst_length > max_nest_burst)                                                                                          // MR: Added 2022/04/29
	max_nest_burst = burst_length;                                                                                            // MR: Added 2022/04/29
      total_bursts++;                                                                                                             // MR: Added 2022/04/29
    }
    NestBurstStats[itDoc->first.as<int>()] = std::make_pair(avg_nest_burst, max_nest_burst);                                      // MR: Added 2022/04/29
  }
  valid = true;
  return true;
}

bool GlobalNestTrace::canShot(const int src_nd, const int now, int &t_pckt, int &dst_nd, int &flit_sz)
{
  /* MR 29 Apr, 2022: Note
   * MR 18 Sep, 2022: Modification
   * MR 17 Oct, 2022: Modification
   * A rather simple processing is possible here, since events in NestTrafficTrace are
   * chronologically ordered. However, it is a good idea to distinguish unicast and local
   * multicast. In the latter case, longer packets may be produced. The maximum packet 
   * length needs to be reasonable compared to the buffer depth even though virtual channels 
   * are used. For destination address driven local multicast, spike information for all
   * >>target neurons<< in the same target node produced by the current source node in the
   * current time step need to be communicated. For source address driven local multicast, 
   * only source addresses of spiking neurons within the current node need to be communicated 
   * to the taget node, which then needs to perform a target look-up locally.
   */
  bool shoot = false;
  if (NestTraffic.find(src_nd) != NestTraffic.end()) {
    if (!NestTraffic[src_nd].empty()) {
      NestTraceComm ntc = NestTraffic[src_nd].front();
      if (now >= ntc.time) {
	dst_nd = ntc.dst_nd;
	t_pckt = ntc.time;
	shoot = true;
	if (GlobalParams::casting_type == UC) {
	  flit_sz = 1;
	  if (ntc.flt_tot - ntc.flt_snt > 1)
	    NestTraffic[src_nd].front().flt_snt++;
	  else
	    NestTraffic[src_nd].pop();
	}
	else {            // Local multicast
	  int rem_flt = ntc.flt_tot - ntc.flt_snt;
	  if ( rem_flt  <= GlobalParams::max_packet_size) {
	    flit_sz = rem_flt;
	    NestTraffic[src_nd].pop();
	  }
	  else {
	    flit_sz = GlobalParams::max_packet_size;
	    NestTraffic[src_nd].front().flt_snt += GlobalParams::max_packet_size;
	  }
	}
      }
    }
  }
  return shoot;
}

bool GlobalNestTrace::occurrencesAsSource(const int src_nd) {
  bool source = false;
  if (NestTraffic.find(src_nd) != NestTraffic.end()) {
    source = !NestTraffic[src_nd].empty();
  }
  return source;
}

bool GlobalNestTrace::isValid() {
  return valid;
}

int GlobalNestTrace::getMaxNestBurst(const int src_nd) const                                                                  // MR: Added 2022/04/29
{                                                                                                                             // MR: Added 2022/04/29
  if(NestBurstStats.find(src_nd) != NestBurstStats.end())                                                                     // MR: Added 2022/04/29
    return NestBurstStats.find(src_nd)->second.second;                                                                        // MR: Added 2022/04/29
  return 0;                                                                                                                   // MR: Added 2022/04/29
}                                                                                                                             // MR: Added 2022/04/29
                                                                                                                              // MR: Added 2022/04/29
int GlobalNestTrace::getMaxNestBurst() const                                                                                  // MR: Added 2022/04/29
{                                                                                                                             // MR: Added 2022/04/29
  int MaxBurstLength = 0;                                                                                                     // MR: Added 2022/04/29
  for (std::map<int, std::pair<double, int > >::const_iterator it = NestBurstStats.begin(); it != NestBurstStats.end(); ++it) // MR: Added 2022/04/29
  {                                                                                                                           // MR: Added 2022/04/29
    if (it->second.second > MaxBurstLength)                                                                                   // MR: Added 2022/04/29
      MaxBurstLength = it->second.second;                                                                                     // MR: Added 2022/04/29
  }                                                                                                                           // MR: Added 2022/04/29
  return MaxBurstLength;                                                                                                      // MR: Added 2022/04/29
}                                                                                                                             // MR: Added 2022/04/29
                                                                                                                              // MR: Added 2022/04/29
double GlobalNestTrace::getAvgNestBurst(const int src_nd) const                                                               // MR: Added 2022/04/29
{                                                                                                                             // MR: Added 2022/04/29
  if (NestBurstStats.find(src_nd) != NestBurstStats.end())                                                                    // MR: Added 2022/04/29
    return NestBurstStats.find(src_nd)->second.first;                                                                         // MR: Added 2022/04/29
  return 0;                                                                                                                   // MR: Added 2022/04/29
}                                                                                                                             // MR: Added 2022/04/29
                                                                                                                              // MR: Added 2022/04/29
double GlobalNestTrace::getAvgNestBurst() const                                                                               // MR: Added 2022/04/29
{                                                                                                                             // MR: Added 2022/04/29
  int tot = 0;                                                                                                                // MR: Added 2022/04/29
  double avg = 0;                                                                                                             // MR: Added 2022/04/29
  for (std::map<int, std::pair<double, int > >::const_iterator it = NestBurstStats.begin(); it != NestBurstStats.end(); ++it) // MR: Added 2022/04/29
  {                                                                                                                           // MR: Added 2022/04/29
    avg = it->second.first / (double)(tot + 1) + (double) tot / (double)(tot + 1) * avg;                                      // MR: Added 2022/04/29
    tot++;                                                                                                                    // MR: Added 2022/04/29
  }                                                                                                                           // MR: Added 2022/04/29
  return avg;                                                                                                                 // MR: Added 2022/04/29
}                                                                                                                             // MR: Added 2022/04/29

int GlobalNestTrace::t_nest_to_cycle(const double t_nest)
{
  return (int)(t_nest * GlobalParams::nest_time_multiplier / (double) GlobalParams::clock_period_ps);                         // MR: Modified 2022/10/10
}
