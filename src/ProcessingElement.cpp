/*
 * Noxim - the NoC Simulator
 *
 * (C) 2005-2018 by the University of Catania
 * For the complete list of authors refer to file ../doc/AUTHORS.txt
 * For the license applied to these sources refer to file ../doc/LICENSE.txt
 *
 * This file contains the implementation of the processing element
 */
/*\\\********************************************************************************
 * Downloaded March 23, 2022 from
 * https://github.com/davidepatti/noxim/tree/c52ebce2217e57bcd4ff11a97b400323bd00acd5
 ************************************************************************************
 *
 * McAERsim - NoC simulator with tree-based multicast support for AER packets
 * Modifications Copyright (C) 2022-2023 Forschungszentrum Juelich GmbH, ZEA-2
 * Author: Markus Robens <https://www.fz-juelich.de/profile/robens_m>
 * For the license applied to these modifications and McAERsim as a whole
 * refer to file ../doc/LICENSE_MCAERSIM.txt
 * 
 * 2022-09-11: McAERsim focuses on traffic generated by NEST and does not implement
 *             statistical traffic models and their support functions. The canShot()
 *             method has been simplified accordingly. Adaptations for the different 
 *             communications data type have been performed and functions that have 
 *             become obsolete due to their single flit nature have been removed.
 *             The txProcess() has been revised and logging has been slightly
 *             modified. Function getQueuedAEREvts() has been added while function
 *             getQueueSize() was removed.
 *
 *///******************************************************************************** 

#include "ProcessingElement.h"

void ProcessingElement::rxProcess()
{
  if (reset.read())
  {
    ack_rx.write(0);
    current_level_rx = 0;
  }
  else
  {
    if (req_rx.read() == 1 - current_level_rx)
    {
      AER_EVT evt_tmp = evt_rx.read();
      LOG << "Processing Element [" << tile_id << "][" << local_id << "] received AER_EVT: " << evt_tmp << std::endl;
      // Toggle the line of the Alternating Bit Protocoll
      current_level_rx = 1 - current_level_rx;
    }
    ack_rx.write(current_level_rx);
  }
}

void ProcessingElement::txProcess()
{
  if (reset.read())
  {
    req_tx.write(0);
    current_level_tx = 0;
  }
  else
  {
    if (l_evt_q.isValid())
    {
      if (canShot())
      {
	if (ack_tx.read() == current_level_tx)
	{
	  int global_id = tile_id * NO_PES + local_id;                            // Global ID of the processing element
	  AER_EVT evt(l_evt_q.Front().first, global_id, l_evt_q.Front().second);  // Generate a new AER_EVT
	  evt_tx->write(evt);                                                     // Sent the generated AER_EVT
	  current_level_tx = 1 - current_level_tx;                                // Toggle the line of the Alternating Bit Protocol (ABP)
	  req_tx.write(current_level_tx);                                         // Update the request line according to the ABP 
	  l_evt_q.Pop();                                                          // AER event of the head of the local queue is locally
	                                                                          // buffered and needs to be removed from the head of the queue
	  ++queuedAEREvts;                                                        // Update the number of queued AER events
	}
      }
    }
  }
}

bool ProcessingElement::canShot()
{
  bool shot = false;
  double now = sc_time_stamp().to_double() / GlobalParams::clock_period_ps;
  double scheduled = l_evt_q.Front().second * GlobalParams::nest_time_multiplier / (double) GlobalParams::clock_period_ps + GlobalParams::reset_time;
  if (now >= scheduled)
  {
    shot = true;
  }
  return shot;
}

long ProcessingElement::getQueuedAEREvts() const
{
  return queuedAEREvts;
}
