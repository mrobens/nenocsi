/*
 * Noxim - the NoC Simulator
 *
 * (C) 2005-2018 by the University of Catania
 * For the complete list of authors refer to file ../../doc/AUTHORS.txt
 * For the license applied to these sources refer to file ../../doc/LICENSE.txt
 *
 */
/*\\\********************************************************************************
 * Downloaded March 23, 2022 from
 * https://github.com/davidepatti/noxim/tree/c52ebce2217e57bcd4ff11a97b400323bd00acd5
 ************************************************************************************
 *
 * McAERsim - NoC simulator with tree-based multicast support for AER packets
 * Modifications Copyright (C) 2022-2023 Forschungszentrum Juelich GmbH, ZEA-2
 * Author: Markus Robens <https://www.fz-juelich.de/profile/robens_m>
 * For the license applied to these modifications and McAERsim as a whole
 * refer to file ../../doc/LICENSE_MCAERSIM.txt
 * 
 * 2022-09-23: This file contains the implementation of the global neuron assignment
 *             table. This table is an auxiliary data structure that helps to
 *             configure the processing elements or more specifically their local
 *             event queues based on a file that is generated by the NEST
 *             microcircuit model. This file contains the neuron number limits for
 *             the single populations.
 *             Code segments required for the plug-in mechanism are in line with
 *             respective code segments in, e.g. Routing_XY.cpp of the Noxim release. 
 *             However, there are several additions. Especially, virtual prototype 
 *             methods of the abstract base class GlobalNeuronAssignmentTable are 
 *             overloaded in such a way that local event queues of the processing 
 *             elements are populated consistent with sequential neuron mapping. 
 *             (I.e., neuron populations are assigned sequentially to available 
 *             processing elements.)
 *             Population limits are read-in by the load(..., ...) method in a 
 *             similar fashion as read-in is performed by the load(...) method of 
 *             GlobalRoutingTable.cpp in the Noxim release.
 *
 *///******************************************************************************** 

#include "GlobalNeuronAssignmentTable_Seq.h"

GlobalNeuronAssignmentTablesRegister GlobalNeuronAssignmentTable_Seq::globalNeuronAssignmentTablesRegister("gnat_seq", getInstance());

GlobalNeuronAssignmentTable_Seq* GlobalNeuronAssignmentTable_Seq::globalNeuronAssignmentTable_Seq = 0;

GlobalNeuronAssignmentTable_Seq* GlobalNeuronAssignmentTable_Seq::getInstance()
{
  if (globalNeuronAssignmentTable_Seq == 0)
    globalNeuronAssignmentTable_Seq = new GlobalNeuronAssignmentTable_Seq();

  return globalNeuronAssignmentTable_Seq;
}

bool GlobalNeuronAssignmentTable_Seq::load(const std::string& pe_conf_input_filename)
{
  std::string delimiter = "$";
  size_t pos = 0;
  if (!((pos = pe_conf_input_filename.find(delimiter)) != std::string::npos))
  {
    std::cerr << "Invalid PE configuration string!" << std::endl;
    std::cerr << "Expecting two filenames separated by the $ sign." << std::endl;
    return false;
  }
  return load(pe_conf_input_filename.substr(0, pos), pe_conf_input_filename.substr(pos + delimiter.length(), std::string::npos));
}
  
bool GlobalNeuronAssignmentTable_Seq::load(const std::string& pop_limits_fname, const std::string& spk_rec_fname)
{
  // Composes a vector of population neuron ID limits
  std::ifstream fin_pop(pop_limits_fname, std::ios::in);
  if (!fin_pop)
    return false;

  bool stop = false;
  while (!fin_pop.eof() && !stop)
  {
    char line[128];
    fin_pop.getline(line, sizeof(line) - 1);
    if (line[0] == '\0')
      stop = true;
    else
    {
      int first_neuron, last_neuron;
      if (sscanf(line, "%d %d", &first_neuron, &last_neuron) == 2)
      {
        gnassigntab.push_back(popLimits(first_neuron, last_neuron));
      }
      else
        assert(false);
    }
  }

  // Generates a string array from the spike recorder base
  // name so that the actual spike recorder file name for
  // a given neuron or neuron range can be computed
  int sdn_fn_comps = 0;                                      // Number of substrings in spike detector file name
  std::string delimiter = "-";                               // Delimiter used
  std::string sdn = spk_rec_fname;                           // Copy of the spike recorder base name that can be modified
  size_t pos = 0;
  while ((pos = sdn.find(delimiter)) != std::string::npos)
  {
    if (sdn_fn_comps >= 3)
    {
      std::cerr << "Invalid name of spike recorder file!" << std::endl;
      std::cerr << "Too many dashes included." << std::endl;
      return false;
    }
    spk_rec_fname_comps[sdn_fn_comps] = sdn.substr(0, pos);
    sdn.erase(0, pos + delimiter.length());
    ++sdn_fn_comps;
  }
  if (sdn_fn_comps != 2)
  {
    std::cerr << "Invalid name of spike recorder file!" << std::endl;
    std::cerr << "Does not split into three components delimited by dashes." << std::endl;
    return false;
  }
  spk_rec_fname_comps[sdn_fn_comps] = sdn;
  valid = true;
  return true;
}

bool GlobalNeuronAssignmentTable_Seq::getSpkRecFileParams(const int node_id, const int proc_id, std::string& spk_rec_fname, int& id_min, int& id_max)
{
  if (!isValid())
  {
    std::cerr << "GlobalNeuronAssignmentTable was not successfully initialized before!" << std::endl;
    return false;
  }
  bool found = false;
  int pop_no = INVALID;
  // Initially, the remaining number of PEs is equal to the available number of PEs
  int pes_remain = (NO_PES * node_id) + proc_id + 1;
  int neurons_previous = 0;
  for (size_t i = 0; i < gnassigntab.size(); ++i)
  {
    int neurons_in_pop = gnassigntab[i].second - gnassigntab[i].first + 1;
    int pes_required = (int)(ceil((double)neurons_in_pop / (double)GlobalParams::neurons_per_node));

    if (pes_remain > pes_required)
    {
      pes_remain -= pes_required;
      neurons_previous += neurons_in_pop;
    }
    else if (pes_remain == pes_required)
    {
      id_min = neurons_previous + (pes_remain - 1) * GlobalParams::neurons_per_node + 1;
      id_max = gnassigntab[i].second;
      pop_no = i;
      found = true;
      break;
    }
    else
    {
      id_min = neurons_previous + (pes_remain - 1) * GlobalParams::neurons_per_node + 1;
      id_max = neurons_previous + pes_remain * GlobalParams::neurons_per_node;
      pop_no = i;
      found = true;
      break;
    }
  }
    
  if (found)
  {
    spk_rec_fname = spk_rec_fname_comps[0] + "-" + std::to_string(std::stoi(spk_rec_fname_comps[1]) + pop_no) + "-" + spk_rec_fname_comps[2];
    return true;
  }
  return false;
}
